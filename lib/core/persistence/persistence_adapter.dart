/// # PersistenceAdapter
///
/// ## What it does
/// Abstraction layer for database operations. Allows swapping persistence
/// backends (ObjectBox, IndexedDB) without changing repository code.
///
/// ## What it enables
/// - ObjectBox on native platforms (Android, iOS, desktop)
/// - IndexedDB on web
/// - Same EntityRepository code works with both
/// - Each implementation handles vector search its own way
///
/// ## Usage
/// ```dart
/// // Native platforms
/// final adapter = ObjectBoxNoteAdapter(store);
/// final repo = NoteRepository(adapter: adapter);
///
/// // Web
/// final adapter = IndexedDBNoteAdapter(database);
/// final repo = NoteRepository(adapter: adapter);
///
/// // Repository API unchanged
/// await repo.save(note);
/// final results = await repo.semanticSearch('query');
/// ```

import '../base_entity.dart';
import 'transaction_context.dart';

/// Core persistence operations for entities.
///
/// Each entity type needs its own adapter implementation because:
/// 1. ObjectBox uses codegen with entity-specific Box<T>
/// 2. Query methods vary by entity fields
/// 3. Vector search configuration is entity-specific
///
/// ## Transaction Support
/// Adapters provide dual APIs:
/// - Async methods (save, delete, etc.) for normal operations
/// - Synchronous *InTx methods for use within transactions
///
/// Transaction methods receive a TransactionContext which platform-specific
/// adapters cast to their concrete type (ObjectBoxTxContext, IndexedDBTxContext).
abstract class PersistenceAdapter<T extends BaseEntity> {
  // ============ CRUD ============

  /// Find entity by UUID (universal identifier).
  /// Returns null if not found.
  /// All entities use UUID as primary key - this is the primary lookup method.
  Future<T?> findById(String uuid);

  /// Get entity by UUID (universal identifier).
  /// Throws EntityNotFoundException if not found.
  ///
  /// Use this when the entity MUST exist (e.g., loading for update).
  /// Use findById() when the entity is optional.
  Future<T> getById(String uuid);

  /// Find entity by internal database ID (legacy).
  /// Returns null if not found.
  /// Use findById(uuid) instead - this is for backwards compatibility only.
  @deprecated
  Future<T?> findByIntId(int id);

  /// Get entity by internal database ID (legacy).
  /// Throws EntityNotFoundException if not found.
  /// Use getById(uuid) instead - this is for backwards compatibility only.
  @deprecated
  Future<T> getByIntId(int id);

  /// Get all entities of this type.
  Future<List<T>> findAll();

  /// Save entity (insert if new, update if exists).
  /// Returns the entity with id assigned.
  ///
  /// For Embeddable entities: indexes the embedding if present.
  /// The adapter handles both document storage and vector indexing.
  ///
  /// If touch=false, skip updatedAt update. Used for background async
  /// operations that update entities without user action (e.g., embedding
  /// generation). Prevents updatedAt collision on side-effect updates.
  Future<T> save(T entity, {bool touch = true});

  /// Batch save multiple entities.
  /// Returns entities with ids assigned.
  Future<List<T>> saveAll(List<T> entities);

  /// Delete entity by UUID.
  /// Returns true if entity was deleted, false if not found.
  /// Also removes from vector index if applicable.
  Future<bool> delete(String uuid);

  /// Delete entity by internal database ID (legacy).
  /// Returns true if entity was deleted, false if not found.
  /// Also removes from vector index if applicable.
  /// Use delete(uuid) instead - this is for backwards compatibility only.
  @deprecated
  Future<bool> deleteByIntId(int id);

  /// Batch delete entities by UUIDs.
  /// Also removes from vector index if applicable.
  Future<void> deleteAll(List<String> uuids);

  // ============ Queries ============

  /// Find entities pending sync (syncStatus == SyncStatus.local).
  /// Used by sync service to push local changes to remote.
  Future<List<T>> findUnsynced();

  /// Count of all entities.
  Future<int> count();

  // ============ Semantic Search ============

  /// Search entities by vector similarity.
  ///
  /// [queryVector] - Embedding of the search query (generated by caller)
  /// [limit] - Maximum results to return
  /// [minSimilarity] - Minimum similarity threshold (0.0 to 1.0)
  ///
  /// Returns entities sorted by descending similarity.
  ///
  /// Implementation varies:
  /// - ObjectBox: Native HNSW via nearestNeighbors query
  /// - IndexedDB: Separate local_hnsw index + document lookup
  Future<List<T>> semanticSearch(
    List<double> queryVector, {
    int limit = 10,
    double minSimilarity = 0.0,
  });

  /// Number of vectors currently in the search index.
  /// Returns 0 if entity type doesn't support embeddings.
  int get indexSize;

  /// Rebuild the vector index from all stored entities.
  ///
  /// [generateEmbedding] - Callback to generate embedding for entities
  /// that have null embeddings. This allows the adapter to request
  /// embedding generation without depending on EmbeddingService.
  ///
  /// Use when:
  /// - Index is missing or corrupt
  /// - Migrating from another storage backend
  /// - Recovering from failed sync
  Future<void> rebuildIndex(
    Future<List<double>?> Function(T entity) generateEmbedding,
  );

  // ============ Transaction Operations ============
  // These methods are synchronous and must be called within a transaction.
  // They receive a TransactionContext which platform implementations cast
  // to their specific type (ObjectBoxTxContext, IndexedDBTxContext).

  /// Find entity by UUID within a transaction (synchronous).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  /// Returns null if not found.
  T? findByIdInTx(TransactionContext ctx, String uuid);

  /// Find entity by int ID within a transaction (synchronous, deprecated).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  /// Returns null if not found.
  @deprecated
  T? findByIntIdInTx(TransactionContext ctx, int id);

  /// Find all entities within a transaction (synchronous).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  List<T> findAllInTx(TransactionContext ctx);

  /// Save entity within a transaction (synchronous).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  /// Platform implementations cast ctx to their specific type.
  ///
  /// Returns the entity with id assigned.
  ///
  /// If touch=false, skip updatedAt update. Used for background async
  /// operations that update entities without user action (e.g., embedding
  /// generation). Prevents updatedAt collision on side-effect updates.
  T saveInTx(TransactionContext ctx, T entity, {bool touch = true});

  /// Batch save entities within a transaction (synchronous).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  /// Returns entities with ids assigned.
  List<T> saveAllInTx(TransactionContext ctx, List<T> entities);

  /// Delete entity by UUID within a transaction (synchronous).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  /// Returns true if deleted, false if not found.
  bool deleteInTx(TransactionContext ctx, String uuid);

  /// Delete entity by int ID within a transaction (synchronous, deprecated).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  /// Returns true if deleted, false if not found.
  @deprecated
  bool deleteByIntIdInTx(TransactionContext ctx, int id);

  /// Batch delete entities by UUIDs within a transaction (synchronous).
  ///
  /// Must be called within TransactionManager.transaction() callback.
  void deleteAllInTx(TransactionContext ctx, List<String> uuids);

  // ============ Lifecycle ============

  /// Close the adapter and release resources.
  /// Call when the repository is no longer needed.
  Future<void> close();
}
