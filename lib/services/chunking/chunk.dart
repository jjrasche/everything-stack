/// Represents a semantic chunk of text with position and optional embedding
///
/// Chunks are segments of text that maintain semantic coherence. Each chunk
/// tracks its position in tokens (not characters) and can store a vector
/// embedding for semantic search within the chunk.
///
/// Token positions use a simple word-based tokenization (whitespace splitting)
/// rather than subword tokenization. This is sufficient for chunk boundary
/// tracking and size calculations.
class Chunk {
  /// The text content of this chunk
  final String text;

  /// Starting token position in the original text (inclusive)
  final int startToken;

  /// Ending token position in the original text (exclusive)
  final int endToken;

  /// Optional embedding vector for this chunk (384 dimensions)
  /// Generated by EmbeddingService if needed for chunk-level search
  final List<double>? embedding;

  Chunk({
    required this.text,
    required this.startToken,
    required this.endToken,
    this.embedding,
  }) {
    if (startToken < 0) {
      throw ArgumentError('startToken must be non-negative');
    }
    if (endToken <= startToken) {
      throw ArgumentError('endToken must be greater than startToken');
    }
    if (text.isEmpty) {
      throw ArgumentError('text cannot be empty');
    }
  }

  /// Number of tokens in this chunk
  int get tokenCount => endToken - startToken;

  /// Whether this chunk has an embedding vector
  bool get hasEmbedding => embedding != null && embedding!.isNotEmpty;

  /// Create a copy with updated properties
  Chunk copyWith({
    String? text,
    int? startToken,
    int? endToken,
    List<double>? embedding,
  }) {
    return Chunk(
      text: text ?? this.text,
      startToken: startToken ?? this.startToken,
      endToken: endToken ?? this.endToken,
      embedding: embedding ?? this.embedding,
    );
  }

  @override
  String toString() {
    return 'Chunk(tokens: $tokenCount, start: $startToken, end: $endToken, '
        'hasEmbedding: $hasEmbedding)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Chunk &&
        other.text == text &&
        other.startToken == startToken &&
        other.endToken == endToken;
  }

  @override
  int get hashCode => Object.hash(text, startToken, endToken);

  /// Convert to JSON for serialization
  Map<String, dynamic> toJson() {
    return {
      'text': text,
      'startToken': startToken,
      'endToken': endToken,
      'embedding': embedding,
    };
  }

  /// Create from JSON
  factory Chunk.fromJson(Map<String, dynamic> json) {
    return Chunk(
      text: json['text'] as String,
      startToken: json['startToken'] as int,
      endToken: json['endToken'] as int,
      embedding: json['embedding'] != null
          ? List<double>.from(json['embedding'] as List)
          : null,
    );
  }
}
